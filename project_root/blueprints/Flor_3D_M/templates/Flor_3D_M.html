<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Flor paramétrica 3D</title>
  <style>
    body {
      margin: 0;
      background: linear-gradient(135deg, #000000 0%, #1a1a2e 100%);
      overflow: hidden;
      height: 100vh;
    }
    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
      touch-action: none; /* Prevent scrolling on touch devices */
    }

    @media (orientation: portrait) {
      canvas {
        height: calc(var(--vh, 1vh) * 100);
      }
    }
  </style>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.min.js"></script>
<script>
  // Fix for mobile viewport height
  function setViewportHeight() {
    let vh = window.innerHeight * 0.01;
    document.documentElement.style.setProperty('--vh', `${vh}px`);
  }
  setViewportHeight();
  window.addEventListener('resize', setViewportHeight);
</script>
<script>
  const n = 900;
  const A = 1.6;
  const B = 1.2;
  const C = 5;
  const petalNum = 6;
  const offset_z = -0.5;

  const r = [];
  const theta = [];
  for (let i = 0; i < n; i++) {
    r.push(i / (n - 1) * 0.9); // evitar bordes extremos
    theta.push(2 * Math.PI * petalNum * i / (n - 1)); // mantener flor cerrada
  }

  const positions = [];
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < n; j++) {
      const R = r[j];
      const THETA = theta[i];

      let modVal = (petalNum * THETA) % (2 * Math.PI);
      let term = (5 / 4) * (1 - modVal / Math.PI) ** 2 - 1 / 4;
      let x = 1 - 0.5 * term ** 2;

      let phi = (Math.PI / 2) * Math.exp(-THETA / (C * Math.PI));
      let y = A * (R ** 2) * ((B * R - 1) ** 2) * Math.sin(phi);

      let R2 = x * (R * Math.sin(phi) + y * Math.cos(phi));
      let X = R2 * Math.sin(THETA);
      let Y = R2 * Math.cos(THETA);
      let Z = x * (R * Math.cos(phi) - y * Math.sin(phi)) + offset_z;

      positions.push(new THREE.Vector3(X, Y, Z));
    }
  }

  // Crear la escena y cámara
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(15, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.z = window.innerWidth < 768 ? 15 : 10;
  camera.lookAt(scene.position);

  // Renderer
  const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
  renderer.setPixelRatio(window.devicePixelRatio || 1);
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.25;
  document.body.appendChild(renderer.domElement);

  // Geometría
  const geometry = new THREE.BufferGeometry();
  const vertices = new Float32Array(positions.length * 3);
  const colors = new Float32Array(positions.length * 3);

  for (let i = 0; i < positions.length; i++) {
    const p = positions[i];
    vertices[i * 3] = p.x;
    vertices[i * 3 + 1] = p.y;
    vertices[i * 3 + 2] = p.z;

    const zNorm = (p.z + 1.5) / 3.0;
    colors[i * 3] = 1.0;
    colors[i * 3 + 1] = 0.3 + 0.7 * zNorm;
    colors[i * 3 + 2] = 0.5 + 0.5 * (1 - zNorm);
  }

  geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
  geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

  // Índices de triángulos
  const indices = [];
  for (let i = 0; i < n - 1; i++) {
    for (let j = 0; j < n - 1; j++) {
      let a = i * n + j;
      let b = (i + 1) * n + j;
      let c = (i + 1) * n + (j + 1);
      let d = i * n + (j + 1);
      indices.push(a, b, d);
      indices.push(b, c, d);
    }
  }
  geometry.setIndex(indices);
  geometry.computeVertexNormals();

  // Material con colores por vértice
  const material = new THREE.MeshLambertMaterial({
    vertexColors: true,
    side: THREE.DoubleSide,
    transparent: true,
    opacity: 0.95
  });

  const mesh = new THREE.Mesh(geometry, material);
  mesh.position.set(0, 0, 0);

  // Aplicar rotación para orientar igual que el segundo código
  mesh.rotation.x = -20;

  scene.add(mesh);

  // Iluminación
  scene.add(new THREE.AmbientLight(0x333333, 0.5));

  const dirLight1 = new THREE.DirectionalLight(0x2196F3, 1);
  dirLight1.position.set(5, 5, 5);
  scene.add(dirLight1);

  const dirLight2 = new THREE.DirectionalLight(0x64B5F6, 0.8);
  dirLight2.position.set(-5, -5, -5);
  scene.add(dirLight2);

  const pointLight = new THREE.PointLight(0xE91E63, 0.5, 20);
  pointLight.position.set(0, 0, 10);
  scene.add(pointLight);

  // Animación con rotación
  function animate() {
    requestAnimationFrame(animate);
    mesh.rotation.z += 0.002; // Rotación lenta en el eje Y
    renderer.render(scene, camera);
  }
  animate();

  // Redimensionar ventana
  function handleResize() {
    const width = window.innerWidth;
    const height = window.innerHeight;

    camera.aspect = width / height;
    camera.updateProjectionMatrix();
    renderer.setSize(width, height);

    // Adjust camera position based on screen size
    camera.position.z = width < 768 ? 15 : 10;
  }

  window.addEventListener('resize', handleResize);
  handleResize(); // Call initially to set up
</script>
</body>
</html>