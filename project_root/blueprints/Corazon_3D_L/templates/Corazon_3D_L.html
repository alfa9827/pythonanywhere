<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Corazon 3D L</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: black;
    }
    canvas {
      position: absolute;
    }
  </style>
</head>
<body>
  <script src="https://cdn.jsdelivr.net/npm/three@0.136.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.136.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://unpkg.com/gsap@3/dist/gsap.min.js"></script>

  <script>
    console.clear();

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 50000);
    camera.position.z = 200;

    const renderer = new THREE.WebGLRenderer({antialias: true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);

    const light1 = new THREE.PointLight(0xffaaaa, 1, 200);
    light1.position.set(50, 50, 50);
    scene.add(light1);

    const light2 = new THREE.PointLight(0xaa88ff, 0.8, 200);
    light2.position.set(-50, -50, -50);
    scene.add(light2);

    scene.add(new THREE.AmbientLight(0xffffff, 0.3));

    function heart3D(x, y, z) {
      const a = Math.pow((x*x + (9.0/4.0)*y*y + z*z - 1), 3);
      const b = x*x * z*z*z;
      const c = (9.0/80.0) * y*y * z*z*z;
      return a - b - c;
    }

    const positions = [];
    const colors = [];
    const totalPoints = 70000;
    const scale = 80;

    for (let i = 0; i < totalPoints; i++) {
      const x = (Math.random() * 2 - 1) * 1.4;
      const y = (Math.random() * 2 - 1) * 1.4;
      const z = (Math.random() * 2 - 1) * 1.4;

      const val = heart3D(x, y, z);
      if (val <= 0 && val > -8) {
        positions.push(x * scale, y * scale, z * scale);

        const dist = Math.sqrt(x*x + y*y + z*z);
        const color = new THREE.Color();
        color.setHSL(0.96, 1.0, 0.3 + dist * 0.4);
        colors.push(color.r, color.g, color.b);
      }
    }

    const geometry = new THREE.BufferGeometry();
    geometry.setAttribute("position", new THREE.Float32BufferAttribute(positions, 3));
    geometry.setAttribute("color", new THREE.Float32BufferAttribute(colors, 3));

    const textureLoader = new THREE.TextureLoader();
    const circleTexture = textureLoader.load("https://threejs.org/examples/textures/sprites/circle.png");

    const material = new THREE.PointsMaterial({
      size: 2,
      map: circleTexture,
      transparent: true,
      alphaTest: 0.5,      // evita bordes cuadrados
      vertexColors: null
    });



    const heart = new THREE.Points(geometry, material);
    heart.rotation.x = -Math.PI / 2;
    scene.add(heart);

    gsap.to(scene.rotation, {
      y: "+=6.28",
      duration: 35,
      repeat: -1,
      ease: "none"
    });

    function render() {
      requestAnimationFrame(render);
      renderer.render(scene, camera);
    }

    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    render();
  </script>
</body>
</html>
