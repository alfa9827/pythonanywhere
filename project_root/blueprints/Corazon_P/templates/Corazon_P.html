<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<title>Corazon Particulas</title>
<style>
  body {
    margin: 0;
    padding: 0;
    overflow: hidden;
    background-color: black;
  }
  canvas {
    background: black;
    display: block;
    margin: 0 auto;
  }
</style>
</head>
<body>
<canvas id="canvas"></canvas>
<script>
  let ANCHO_VENTANA = window.innerWidth;
  let ALTURA_VENTANA = window.innerHeight;
  const COLOR_FONDO = 'black';
  const TAMAÑO_PARTICULA = Math.max(1, Math.min(2, window.innerWidth / 400));
  const DURACION_PARTICULA = 3;
  const NUM_PARTICULAS = 10000;
  const COLOR_PARTICULAS = ['#EA80B0']; // rgb(234,128,176) en hex

  class Particle {
    constructor() {
      this.position = [0, 0];
      this.velocity = [0, 0];
      this.acceleration = [0, 0];
      this.age = 0;
      this.color = 'black';
    }
    initialize(x, y, dx, dy, color) {
      this.position = [x, y];
      this.velocity = [dx, dy];
      this.acceleration = [dx * -0.75, dy * -0.75];
      this.age = 0;
      this.color = color;
    }
    update(deltaTime) {
      this.position[0] += this.velocity[0] * deltaTime;
      this.position[1] += this.velocity[1] * deltaTime;
      this.velocity[0] += this.acceleration[0] * deltaTime;
      this.velocity[1] += this.acceleration[1] * deltaTime;
      this.age += deltaTime;
    }
    draw(ctx) {
      const lifeRatio = 1 - this.age / DURACION_PARTICULA;
      const size = TAMAÑO_PARTICULA * lifeRatio;
      if (size <= 0) return;
      const alpha = lifeRatio;
      ctx.beginPath();
      ctx.fillStyle = this.hexToRgba(this.color, alpha);
      ctx.arc(this.position[0], this.position[1], size / 2, 0, 2 * Math.PI);
      ctx.fill();
    }
    hexToRgba(hex, alpha) {
      const r = parseInt(hex.slice(1, 3), 16);
      const g = parseInt(hex.slice(3, 5), 16);
      const b = parseInt(hex.slice(5, 7), 16);
      return `rgba(${r},${g},${b},${alpha})`;
    }
  }

  class ParticlePool {
    constructor(length) {
      this.particles = [];
      for (let i = 0; i < length; i++) {
        this.particles.push(new Particle());
      }
      this.firstActive = 0;
      this.firstFree = 0;
      this.length = length;
    }
    add(x, y, dx, dy, color) {
      this.particles[this.firstFree].initialize(x, y, dx, dy, color);
      this.firstFree = (this.firstFree + 1) % this.length;
      if (this.firstActive === this.firstFree) {
        this.firstActive = (this.firstActive + 1) % this.length;
      }
    }
    update(deltaTime) {
      if (this.firstActive < this.firstFree) {
        for (let i = this.firstActive; i < this.firstFree; i++) {
          this.particles[i].update(deltaTime);
        }
      } else if (this.firstFree < this.firstActive) {
        for (let i = this.firstActive; i < this.length; i++) {
          this.particles[i].update(deltaTime);
        }
        for (let i = 0; i < this.firstFree; i++) {
          this.particles[i].update(deltaTime);
        }
      }
    }
    draw(ctx) {
      for (let i = 0; i < this.length; i++) {
        if (this.firstActive < this.firstFree) {
          if (i >= this.firstActive && i < this.firstFree) {
            this.particles[i].draw(ctx);
          }
        } else if (this.firstFree < this.firstActive) {
          if (!(i >= this.firstFree && i < this.firstActive)) {
            this.particles[i].draw(ctx);
          }
        }
      }
    }
  }

  function pointOnHeart(t) {
    const scale = Math.min(ANCHO_VENTANA, ALTURA_VENTANA) / 800;
    const x = 160 * scale * Math.pow(Math.sin(t), 3);
    const y = scale * (130 * Math.cos(t) - 50 * Math.cos(2 * t) - 20 * Math.cos(3 * t) - 10 * Math.cos(4 * t) + 25);
    return [x, y];
  }

  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  
  function resizeCanvas() {
    ANCHO_VENTANA = window.innerWidth;
    ALTURA_VENTANA = window.innerHeight;
    canvas.width = ANCHO_VENTANA;
    canvas.height = ALTURA_VENTANA;
  }
  window.addEventListener('resize', resizeCanvas);
  resizeCanvas();

  const particles = new ParticlePool(NUM_PARTICULAS);
  const particleRate = NUM_PARTICULAS / DURACION_PARTICULA;

  let lastTime = performance.now() / 1000;

  function loop() {
    const now = performance.now() / 1000;
    let deltaTime = now - lastTime;
    lastTime = now;

    ctx.fillStyle = COLOR_FONDO;
    ctx.fillRect(0, 0, ANCHO_VENTANA, ALTURA_VENTANA);

    const amount = particleRate * deltaTime;
    for (let i = 0; i < amount; i++) {
      const t = Math.PI - 2 * Math.PI * Math.random();
      const pos = pointOnHeart(t);
      const dir = [pos[0], -pos[1]];
      const length = Math.sqrt(dir[0] * dir[0] + dir[1] * dir[1]);
      dir[0] = (dir[0] * (Math.random() * 100 + 50)) / length;
      dir[1] = (dir[1] * (Math.random() * 100 + 50)) / length;
      const color = COLOR_PARTICULAS[Math.floor(Math.random() * COLOR_PARTICULAS.length)];
      particles.add(ANCHO_VENTANA / 2 + pos[0], ALTURA_VENTANA / 2 - pos[1], dir[0], dir[1], color);
    }

    particles.update(deltaTime);
    particles.draw(ctx);

    requestAnimationFrame(loop);
  }

  requestAnimationFrame(loop);
</script>
</body>
</html>